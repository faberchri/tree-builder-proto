package clusterer;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class CachedParallelClosestNodesSearcher implements ClosestNodesSearcher {
	
	private Set<Node> openUserNodes = null;
	private Set<Node> openContentNodes = null;
	private boolean initialized = false;
	
	// Allows concurrent modification of the Map from several threads without the need to block them. 
	private ConcurrentHashMap<Node, NodeDistance> userDistanceCaches = new ConcurrentHashMap<Node, NodeDistance>();
	private ConcurrentHashMap<Node, NodeDistance> contentDistanceCaches = new ConcurrentHashMap<Node, NodeDistance>(); 


	private void init(Set<Node> openNodes) {
		Iterator<Node> i = openNodes.iterator();
		if (! i.hasNext()) return;
		Node n = i.next();
		if (n.getClass().equals(UserNode.class)) {
			this.openUserNodes = openNodes;
		}
		if (n.getClass().equals(MovieNode.class)) {
			this.openContentNodes = openNodes;
		}
		if (openUserNodes != null && openContentNodes != null) {
			this.initialized = true;
		}
	}
	
	public List<Node> getClosestNodes(Set<Node> openNodes) {
		if(! initialized) {
			init(openNodes);
			return getClosestNodesByTotalRecalculation(openNodes);
		} else {
			return getClosestNodesFromCachedDistances(openNodes);
		}
	}
	
	private List<Node> getClosestNodesFromCachedDistances(Set<Node> openNodes, UserNode userN){
		return getClosestNodesFromCachedDistances(openUserNodes, userDistanceCaches);
	}
	
	private List<Node> getClosestNodesFromCachedDistances(Set<Node> openNodes, ConcurrentHashMap<Node, NodeDistance> cache){
		
		
		
		

		NodeDistance closest = Collections.min(distanceCaches.values());
		return closest.getBothNode();
	}
	
	
		
	private List<Node> getClosestNodesByTotalRecalculation(Set<Node> openNodes) {
//		long time = System.currentTimeMillis();
		
		int numOfThreads = Runtime.getRuntime().availableProcessors();
		
		List<Node> nLi = new ArrayList<Node>(openNodes);
		int longIndex = 0;
		int shortIndex = nLi.size() -1 ;
		
		List<List<Integer>> jLi = new ArrayList<List<Integer>>(numOfThreads);
		for (int i = 0; i < numOfThreads; i++) {
			jLi.add(new ArrayList<Integer>());
		}

		int currentJLi = 0;
		
		while (longIndex <= shortIndex) {
			if (currentJLi >= numOfThreads) {
				currentJLi = 0;
			}
			jLi.get(currentJLi).add(new Integer(longIndex));
			jLi.get(currentJLi).add(new Integer(shortIndex));
			currentJLi++;
			longIndex++;
			shortIndex--;
		}
		
		ExecutorService taskExecutor = Executors.newFixedThreadPool(numOfThreads);
		List<ClosestNodeCalculator> taskList = new ArrayList<ClosestNodeCalculator>();
		for (List<Integer> list : jLi) {
			ClosestNodeCalculator task = new ClosestNodeCalculator(list, nLi);
			taskList.add(task);
			taskExecutor.execute(task);
		}
		taskExecutor.shutdown();
		try {
			taskExecutor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		NodeDistance bestND = null;
		for (ClosestNodeCalculator closestNodeCalculator : taskList) {
			if (bestND == null || bestND.getDistance() > closestNodeCalculator.getBestNodeDistance().getDistance()) {
				bestND = closestNodeCalculator.getBestNodeDistance();
			}
		}

		List<Node> res = bestND.getBothNode();

		System.out.println("Closest nodes: "+res.get(0)+", "+res.get(1)+" ("+bestND.getDistance()+")");

//		time = System.currentTimeMillis() - time;
//		System.out.println("Time in getClosestNode() parallel: " + (double)time / 1000.0);
		return res;

	}
	
	private class ClosestNodeCalculator extends Thread{
		
		private final List<Integer> jLi;
		private final List<Node> nLi;
		
		NodeDistance bestNodeDistance = null;
				
		public ClosestNodeCalculator(List<Integer> jLi, List<Node> nLi) {
			this.jLi = jLi;
			this.nLi = nLi;
		}

		@Override
		public void run() {
			for (Integer i : jLi) {
				if (i == nLi.size() - 1) continue;
				NodeDistance tmpDi = nLi.get(i).getDistanceToClosestNode(nLi.subList(i + 1, nLi.size()));
				distanceCaches.put(nLi.get(i), tmpDi);
				if (bestNodeDistance == null || bestNodeDistance.getDistance() > tmpDi.getDistance()) {
					bestNodeDistance = tmpDi;
				}
			}			
		}
		
		public NodeDistance getBestNodeDistance() {
			return bestNodeDistance;
		}
		
	}
}
